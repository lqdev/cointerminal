0 info it worked if it ends with ok
1 verbose cli [ '/opt/node.js-v6.9.1/bin/node', '/usr/bin/npm', 'publish' ]
2 info using npm@3.10.8
3 info using node@v6.9.1
4 verbose publish [ '.' ]
5 silly cache add args [ '.', null ]
6 verbose cache add spec .
7 silly cache add parsed spec Result {
7 silly cache add   raw: '.',
7 silly cache add   scope: null,
7 silly cache add   escapedName: null,
7 silly cache add   name: null,
7 silly cache add   rawSpec: '.',
7 silly cache add   spec: '/home/cedric/inside/github/terminal-kit',
7 silly cache add   type: 'directory' }
8 verbose addLocalDirectory /home/cedric/.npm/terminal-kit/0.25.0/package.tgz not in flight; packing
9 verbose correctMkdir /home/cedric/.npm correctMkdir not in flight; initializing
10 info lifecycle terminal-kit@0.25.0~prepublish: terminal-kit@0.25.0
11 silly lifecycle terminal-kit@0.25.0~prepublish: no script for prepublish, continuing
12 verbose tar pack [ '/home/cedric/.npm/terminal-kit/0.25.0/package.tgz',
12 verbose tar pack   '/home/cedric/inside/github/terminal-kit' ]
13 verbose tarball /home/cedric/.npm/terminal-kit/0.25.0/package.tgz
14 verbose folder /home/cedric/inside/github/terminal-kit
15 verbose addLocalTarball adding from inside cache /home/cedric/.npm/terminal-kit/0.25.0/package.tgz
16 verbose correctMkdir /home/cedric/.npm correctMkdir not in flight; initializing
17 silly cache afterAdd terminal-kit@0.25.0
18 verbose afterAdd /home/cedric/.npm/terminal-kit/0.25.0/package/package.json not in flight; writing
19 verbose correctMkdir /home/cedric/.npm correctMkdir not in flight; initializing
20 verbose afterAdd /home/cedric/.npm/terminal-kit/0.25.0/package/package.json written
21 silly publish { name: 'terminal-kit',
21 silly publish   version: '0.25.0',
21 silly publish   description: '256 colors, keys and mouse, input field, screen buffer, interactive \'yes or no\', and many more... Whether you just need colors and styles, build a simple interactive command line tool or a complexe terminal app: this is the absolute terminal lib for Node.js!',
21 silly publish   main: 'lib/termkit.js',
21 silly publish   directories: { test: 'test' },
21 silly publish   engines: { node: '>=4.5.0' },
21 silly publish   dependencies:
21 silly publish    { 'async-kit': '^2.2.0',
21 silly publish      jshint: '^2.9.4',
21 silly publish      mocha: '^3.1.2',
21 silly publish      'nextgen-events': '^0.9.8',
21 silly publish      'string-kit': '^0.5.11',
21 silly publish      'tree-kit': '^0.5.26' },
21 silly publish   devDependencies: { 'expect.js': '^0.3.1', jshint: '^2.9.3', mocha: '^3.0.2' },
21 silly publish   scripts: { test: 'tea-time -R dot' },
21 silly publish   repository:
21 silly publish    { type: 'git',
21 silly publish      url: 'git+https://github.com/cronvel/terminal-kit.git' },
21 silly publish   keywords:
21 silly publish    [ 'terminal',
21 silly publish      'console',
21 silly publish      'xterm',
21 silly publish      'color',
21 silly publish      '256 colors',
21 silly publish      'style',
21 silly publish      'input',
21 silly publish      'input field',
21 silly publish      'mouse',
21 silly publish      'gpm',
21 silly publish      'cursor',
21 silly publish      'menu',
21 silly publish      'screenbuffer' ],
21 silly publish   author: { name: 'Cédric Ronvel' },
21 silly publish   license: 'MIT',
21 silly publish   bugs: { url: 'https://github.com/cronvel/terminal-kit/issues' },
21 silly publish   copyright:
21 silly publish    { title: 'Terminal Kit',
21 silly publish      years: [ 2009, 2016 ],
21 silly publish      owner: 'Cédric Ronvel' },
21 silly publish   readme: '\n[![★](https://img.shields.io/github/stars/cronvel/terminal-kit.svg?label=❤)](https://github.com/cronvel/terminal-kit/stargazers)\n[![License](https://img.shields.io/github/license/cronvel/terminal-kit.svg)](https://github.com/cronvel/terminal-kit)\n[![Downloads](https://img.shields.io/npm/dm/terminal-kit.svg)](https://www.npmjs.com/package/terminal-kit)\n[![Version](https://img.shields.io/npm/v/terminal-kit.svg)](https://www.npmjs.com/package/terminal-kit)\n[![Codewake](https://www.codewake.com/badges/ask_question.svg)](https://www.codewake.com/p/terminal-kit)\n\n[![Stats](https://nodei.co/npm/terminal-kit.png?downloads=true&downloadRank=true&stars=true)](https://www.npmjs.com/package/terminal-kit)\n\n\n\n# Terminal Kit\n\nA full-blown terminal lib featuring: 256 colors, styles, keys & mouse handling, input field, interactive \'yes or no\', \nscreen buffer, and many more...\n\nWhether you just need colors & styles, build a simple interactive command line tool or a complexe terminal application:\nthis is the absolute terminal lib for Node.js!\n\nIt does **NOT** depend on ncurses.\n\n* License: MIT\n* Current status: **really close to release!**\n* Platform: linux and any xterm-compatible terminal, it has been tested successfully with:\n\t* xterm\n\t* gnome-terminal\n\t* Konsole\n\t* Terminator\n\t* xfce4-terminal\n\t* Linux Console\n\t* rxvt/urxvt\n\t* Eterm\n\t* Terminology\n\t* **Your terminal?** Help tracking terminal compatibilities [on github!](https://github.com/cronvel/terminal-kit/issues)\n\nSome tutorials are available at [blog.soulserv.net/tag/terminal](http://blog.soulserv.net/tag/terminal/).\n\n\n\n## Key features\n\n* colors, 256 colors or even 24 bits colors, if the terminal supports it\n* styles (bold, underline, italic, and many more)\n* style mixing\n* string formatting\n* short style markup\n* cursor positioning\n* keyboard input\n* mouse support (GPM is supported for the Linux Console)\n* terminal window title\n* input field\n* interactive \'yes or no\'\n* screen & off-screen buffers (a concept similar to SDL\'s *Surface*)\n* event-driven\n\n\n\n## Quick examples\n\n```js\n// Require the lib, get a working terminal\nvar term = require( \'terminal-kit\' ).terminal ;\n\n// The term() function simply output a string to stdout, using current style\n// output "Hello world!" in default terminal\'s colors\nterm( \'Hello world!\\n\' ) ;\n\n// This output \'red\' in red\nterm.red( \'red\' ) ;\n\n// This output \'bold\' in bold\nterm.bold( \'bold\' ) ;\n\n// output \'mixed\' using bold, underlined & red, exposing the style-mixing syntax\nterm.bold.underline.red( \'mixed\' ) ;\n\n// printf() style formatting everywhere:\n// this will output \'My name is Jack, I\'m 32.\' in green\nterm.green( "My name is %s, I\'m %d.\\n" , \'Jack\' , 32 ) ;\n\n// Since v0.16.x, style markup are supported as a shorthand.\n// Those two lines produce the same result.\nterm( "My name is " ).red( "Jack" )( " and I\'m " ).green( "32\\n" ) ;\nterm( "My name is ^rJack^ and I\'m ^g32\\n" ) ;\n\n// Width and height of the terminal\nterm( \'The terminal size is %dx%d\' , term.width , term.height ) ;\n\n// Move the cursor at the upper-left corner\nterm.moveTo( 1 , 1 ) ;\n\n// We can always pass additional arguments that will be displayed...\nterm.moveTo( 1 , 1 , \'Upper-left corner\' ) ;\n\n// ... and formated\nterm.moveTo( 1 , 1 , "My name is %s, I\'m %d.\\n" , \'Jack\' , 32 ) ;\n\n// ... or even combined with other styles\nterm.moveTo.cyan( 1 , 1 , "My name is %s, I\'m %d.\\n" , \'Jack\' , 32  ) ;\n```\n\n\n\n## Install\n\nUse Node Package Manager:\n\n    npm install terminal-kit\n\n\n\n## Some conventions used in this document\n\nIn all examples, `termkit` is assumed to be `var termkit = require( \'terminal-kit\' ) ;` while `term` is assumed\nto be `var term = require( \'terminal-kit\' ).terminal ;` or `var term = termkit.terminal ;`.\n\nSo `term` is an instanceof of `termkit.Terminal`, that should in almost all cases match correctly the terminal you\nare currently using. This is the *default* terminal.\n\nYou can also define your own terminal interface, see [.createTerminal()](#ref.createTerminal).\n\n\n\n## Table of Contents\n\n* Basic *chainable* methods\n\t* [Colors](#ref.colors)\n\t* [Styles](#ref.styles)\n\t* [Moving the cursor](#ref.movingCursor)\n\t* [Editing the screen](#ref.editingScreen)\n\t* [Input/Output](#ref.io)\n\t* [Misc](#ref.misc)\n* Advanced usages and methods\n\t* [Real terminal access (e.g. escaping from pipes)](#ref.realTerminal)\n\t* [.fullscreen()](#ref.fullscreen)\n\t* [.grabInput()](#ref.grabInput)\n\t* [.getCursorLocation()](#ref.getCursorLocation)\n\t* [.getColor()](#ref.getColor)\n\t* [.setColor()](#ref.setColor)\n\t* [.getPalette()](#ref.getPalette)\n\t* [.setPalette()](#ref.setPalette)\n\t* [.yesOrNo()](#ref.yesOrNo)\n\t* [.inputField()](#ref.inputField)\n\t* [.singleLineMenu()](#ref.singleLineMenu)\n\t* [.progressBar()](#ref.progressBar)\n\t* [.slowTyping()](#ref.slowTyping)\n* Events\n\t* [\'resize\'](#ref.event.resize)\n\t* [\'key\'](#ref.event.key)\n\t* [\'terminal\'](#ref.event.terminal)\n\t* [\'mouse\'](#ref.event.mouse)\n* Static methods\n\t* [.createTerminal()](#ref.createTerminal)\n\t* [.getParentTerminalInfo()](#ref.getParentTerminalInfo)\n\t* [.getDetectedTerminal()](#ref.getDetectedTerminal)\n\t* [.autoComplete()](#ref.autoComplete)\n\t\n\n\n## Standard methods of a **Terminal** instance \n\nStandard methods map low-level terminal capabilities.\n\nFor all the functions below, additional arguments can be provided.\n\nIf a boolean is provided, it will turn the feature *on* or *off*.\nFor example `term.red( true )` turn all subsequent output in red, while `term.red( false )` disable red and go back to default color.\n\nWithout arguments, it is always the same as *true*, e.g. `term.red()` do the same thing than `term.red()`.\n\nSome function cannot be turned off, they just perform an action.\nFor example `term.reset()` reset the terminal, usually to its default.\nThis is not reversible, thus `term.reset( false )` does nothing.\n\nIf the additional argument is a string, then it will be sent to the output directly after turning *on* the feature... then the\nfeature is turn *off*.\nThat\'s it:  \n`term.red( \'Hello world!\' )`  \n... is the same as:  \n`term.red( true ) ; term( \'Hello world!\' ) ; term.red( false ) ;`.\n\nAlso those string support a printf()-like formatting syntax.  \nSo we can do `term.red( "My name is %s, I\'m %d." , \'Jack\' , 32 )` to output *"My name is Jack, I\'m 32."* in red.\n\n**New:** since *v0.16.x*, style markup are supported as a shorthand. Style markup are introduced by a caret `^` followed by another\ncharacter.\nColors are produced by the first letter of its name, e.g. red is produced with a `^r`, except black which is produced by `^k`.\nOther styles are produced with a symbol. For example `^_` switch to underline.\nTo remove all styles, `^:` or `^ ` can be used.\nA style reset is always produced at the end of the string as soon as one style markup was used.\n\nThose two lines produce the same result:\n```js\nterm( "My name is " ).red( "Jack" )( " and I\'m " ).green( "32\\n" ) ;\nterm( "My name is ^rJack^ and I\'m ^g32\\n" ) ;\n```\n\nSee [the full style markup reference](https://github.com/cronvel/string-kit#ref.format.markup) for details.\n\n\n\nAll those functions are chainable, and their arguments can be combined.\nWe can do:  \n`term.moveTo.red( 1 , 1 , "My name is %s, I\'m %d.\\n" , \'Jack\' , 32  )` which will move the cursor to (1,1), then output *"My name is Jack, I\'m 32."* in red.\n\n\n\n### Common/Misc\n\n* .reset(): full reset of the terminal\n* .error(): it just set error to true so it will write to STDERR instead of STDOUT\n* .str(): do not output anything, instead return a string containing the sequences\n* .bell(): emit an audible bell\n\n\n\n<a name="ref.colors"></a>\n### Foreground colors\n\n* .defaultColor(): back to the default foreground color\n* .black(): ...\n* .red(): ...\n* .green(): ...\n* .yellow(): dark yellow, most of time brown or orange\n* .blue(): ...\n* .magenta(): ...\n* .cyan(): ...\n* .white(): ...\n* .brightBlack(): ...\n* .brightRed(): ...\n* .brightGreen(): ...\n* .brightYellow(): true yellow\n* .brightBlue(): ...\n* .brightMagenta(): ...\n* .brightCyan(): ...\n* .brightWhite(): ...\n* .color(register): choose between 16 colors using an 0..15 integer\n* .darkColor(register): choose between 8 regular (dark) colors using an 0..7 integer\n* .brightColor(register): choose between 8 bright colors using an 0..7 integer\n* .color256(register): if the terminal support 256 colors, it chooses between them using an 0..255 integer\n* .colorRgb(r,g,b): pick the closest match for an RGB value (from a 16 or 256 colors palette or even the \n\texact color if the terminal support 24 bits colors), *r,g,b* are in the 0..255 range\n* .colorGrayscale(l): pick the closest match for a grayscale value (from a 16 or 256 colors palette or\n\teven the exact color if the terminal support 24 bits colors), *l* is in the 0..255 range\n\n\n\n### Background colors\n\n* .bgDefaultColor(): back to the default background color\n* .bgBlack(): ...\n* .bgRed(): ...\n* .bgGreen(): ...\n* .bgYellow(): dark yellow, most of time brown or orange\n* .bgBlue(): ...\n* .bgMagenta(): ...\n* .bgCyan(): ...\n* .bgWhite(): ...\n* .bgDarkColor(): ...\n* .bgBrightBlack(): ...\n* .bgBrightRed(): ...\n* .bgBrightGreen(): ...\n* .bgBrightYellow(): true yellow\n* .bgBrightBlue(): ...\n* .bgBrightMagenta(): ...\n* .bgBrightCyan(): ...\n* .bgColor(register): choose between 16 colors using an 0..15 integer\n* .bgBrightWhite(): choose between 8 regular (dark) colors using an 0..7 integer\n* .bgBrightColor(): choose between 8 bright colors using an 0..7 integer\n* .bgColor256(register): if the terminal support 256 colors, it choose between them using an 0..255 integer\n* .bgColorRgb(r,g,b): pick the closest match for an RGB value (from a 16 or 256 colors palette or even the\n\texact color if the terminal support 24 bits colors) as the background color, *r,g,b* are in the 0..255 range\n* .bgColorGrayscale(l): pick the closest match for a grayscale value (from a 16 or 256 colors palette or even\n\tthe exact color if the terminal support 24 bits colors) as the background color, *l* is in the 0..255 range\n\n\n\n<a name="ref.styles"></a>\n### Styles\n\n* .styleReset(): reset all styles and go back to default colors\n* .bold(): bold text\n* .dim(): faint color\n* .italic(): italic\n* .underline(): underline\n* .blink(): blink text, not widely supported\n* .inverse(): foreground and background color\n* .hidden(): invisible, but can be copy/paste\'d\n* .strike(): strike through\n\n\n\n<a name="ref.movingCursor"></a>\n### Moving the Cursor\n\n* .saveCursor(): save cursor position\n* .restoreCursor(): restore a previously saved cursor position\n* .up(n): move the cursor \'n\' chars up\n* .down(n): move the cursor \'n\' chars down\n* .right(n): move the cursor \'n\' chars right\n* .left(n): move the cursor \'n\' chars left\n* .nextLine(n): move the cursor to beginning of the line, \'n\' lines down\n* .previousLine(n): move the cursor to beginning of the line, \'n\' lines up\n* .column(x): move the cursor to column x\n* .scrollUp(n): scroll whole page up by \'n\' lines, new lines are added at the bottom, the absolute cursor position do not change (Linux Console don\'t support it)\n* .scrollDown(n): scroll whole page down by \'n\' lines, new lines are added at the top, the absolute cursor position do not change (Linux Console don\'t support it)\n* .moveTo(x,y): move the cursor to the (x,y) coordinate (1,1 is the upper-left corner)\n* .move(x,y): relative move of the cursor\n* .hideCursor(): hide/show the cursor\n\n\n\n<a name="ref.editingScreen"></a>\n### Editing the Screen\n\n* .clear(): clear the screen and move the cursor to the upper-left corner\n* .eraseDisplayBelow(): erase everything below the cursor\n* .eraseDisplayAbove(): erase everything above the cursor\n* .eraseDisplay(): erase everything\n* .eraseLineAfter(): erase current line after the cursor\n* .eraseLineBefore(): erase current line before the cursor\n* .eraseLine(): erase current line\n* .insertLine(n): insert n lines\n* .deleteLine(n): delete n lines\n* .insert(n): insert n char after (like the INSERT key)\n* .delete(n): delete n char after (like the DELETE key)\n* .backDelete(): delete one char backward (like the BACKSPACE key), shorthand composed by a .left(1)\n  followed by a .delete(1)\n* .alternateScreenBuffer(): this set/unset the alternate screen buffer, many terminal do not support it or inhibit it\n\n\n\n<a name="ref.io"></a>\n### Input/Output\n\n* .requestCursorLocation(): request the cursor location, a \'terminal\' event will be fired when available\n* .requestScreenSize(): **DEPRECATED** request for screen size, a \'terminal\' event will be fired when available,\n\t**DO NOT USE**: use .width and .height instead, those properties are updated whenever a resize event is received\n* .requestColor(n): **rarely useful** request for color *n*, **DO NOT USE**: use high-level .getColor() instead\n* .applicationKeypad(): should allow keypad to send different code than 0..9 keys, not widely supported\n\n\n\n### Internal input/output (do not use directly, use grabInput() instead)\n\n* .mouseButton(): ask the terminal to send event when a mouse button is pressed, with the mouse cursor position\n* .mouseDrag(): ask the terminal to send event when a mouse button is pressed and when draging, with the mouse cursor position\n* .mouseMotion(): ask the terminal to send all mouse event, even mouse motion that occurs without buttons\n* .mouseSGR(): another mouse protocol that extend coordinate mapping (without it, it supports only 223 rows and columns)\n* .focusEvent(): ask the terminal to send event when it gains and loses focus, not widely supported\n\n\n\n<a name="ref.misc"></a>\n### Misc\n\n* .noFormat(str): disable string formatting - useful when your string may contain `%` (e.g. user input) and you\n\tdon\'t want to escape them\n* .windowTitle(str): set the title of an xterm-compatible window to *str*\n* .setCursorColor(register): set the cursor color to one of the 256 *register*\n* .setCursorColorRgb(r,g,b): set the cursor color to a custom RGB value\n* .setDefaultColorRgb(r,g,b): set the value of the default foreground color\n* .setDefaultBgColorRgb(): set the value of the default background color, this is the terminal window background\n\n\n\n## Advanced methods of a **Terminal** instance\n\nAdvanced methods are high-level library functions.\n\n\n\n<a name="ref.realTerminal"></a>\n### Getting the **REAL** terminal access (e.g. escaping from pipes)\n\nWhen a program is piped, its standard input (STDIN) or its standard output (STDOUT) is no longer connected to the actual terminal,\nbut to an upstream or downstream program.\n\nSometime this is the behavior you want, sometime not.\n\nThe default terminal instance (`require( \'terminal-kit\' ).terminal`) use STDIN and STDOUT as its input and output, so if the program\nis piped, it get its input from the upstream program and/or send its output to the downstream program.\n\nHowever, one may want a direct access to the terminal even when piped.\n\nFor that purpose, `termkit.tty.getInput()` and `termkit.tty.getOutput()` can be used instead of `process.stdin` and `process.stdout`,\nand passed to [`termkit.createTerminal()`](#ref.createTerminal).\n\nTo ease this process even more, there is another built-in terminal instance for that: `require( \'terminal-kit\' ).realTerminal`.\n\nLet\'s write this file (my-script.js):\n\n```js\nrealTerm = require( "terminal-kit" ).realTerminal ;\nrealTerm.blue( "Enter your name: " ) ;\nrealTerm.inputField( function( error , name ) {\n\trealTerm.green( "\\nHello %s!\\n" , name ) ;\n\tprocess.exit() ;\n} ) ;\n```\n\nAnd then execute it from the command line using pipes: `someprogram | node my-script.js | someotherprogram`.\n\nThe script will totally escape the pipes and will be able to run the same way it would without pipes.\n\n**Furthermore:** you can still receive and send things from STDIN and to STDOUT, so you can handle interactive stuff using\nthe `realTerm` instance and receive from the first program, and write to the last program.\n\n\n\n<a name="ref.fullscreen"></a>\n### .fullscreen( options )\n\n* options: true/false/object: if truthy it activate fullscreen mode, falsy return to normal mode,\n  if it is an object it supports those properties:\n\t* noAlternate `boolean` true if the alternate screen buffer should not be used\n\nBasically, this method try to achieve the same goal than the native terminal capability *alternate screen buffer*.\nIf *alternate screen buffer* is disabled on your terminal, it will provide a clean fallback, clearing the screen and positionning\nthe cursor at the upper-left corner.\n\n\n\n<a name="ref.processExit"></a>\n### .processExit( code )\n\n* code `number` the exit code\n\nThis method should be used instead of calling `process.exit()` directly. The *code* argument will be transmitted to\n`process.exit()` as it is.\n\nIt helps quitting cleanly your application without leaving the terminal in a bad state, so the user get a working shell back.\n\n\n\n<a name="ref.grabInput"></a>\n### .grabInput( options )\n\n* options: false/true/Object, *false* disable input grabbing, *true* or an Object turn it on,\n  if it is an Object then those properties are supported:\n\t* mouse: if defined, it activate mouse event, those values are supported for \'mouse\':\n\t\t* \'button\': report only button-event\n\t\t* \'drag\': report button-event and report motion-event only when a button is pressed (i.e. a mouse drag)\n\t\t* \'motion\': report button-event and all motion-event, use it only when needed, many escape sequences are sent from\n\t\t  the terminal (e.g. you may consider it for script running over SSH)\n\t* focus: true/false: if defined and true, focus event will be reported (if your terminal support it - *xterm* does)\n\nThis function turns input grabbing on, keyboard entries will not be echoed, and every input will generate an event\non the `term` object.\n\n\nQuick example:\n\n```js\nvar term = require( \'terminal-kit\' ).terminal ;\n\nfunction terminate()\n{\n\tterm.grabInput( false ) ;\n\tsetTimeout( function() { process.exit() } , 100 ) ;\n}\n\nterm.bold.cyan( \'Type anything on the keyboard...\\n\' ) ;\nterm.green( \'Hit CTRL-C to quit.\\n\\n\' ) ;\n\nterm.grabInput( { mouse: \'button\' } ) ;\n\nterm.on( \'key\' , function( name , matches , data ) {\n\tconsole.log( "\'key\' event:" , name ) ;\n\tif ( key === \'CTRL_C\' ) { terminate() ; }\n} ) ;\n\nterm.on( \'terminal\' , function( name , data ) {\n\tconsole.log( "\'terminal\' event:" , name , data ) ;\n} ) ;\n\nterm.on( \'mouse\' , function( name , data ) {\n\tconsole.log( "\'mouse\' event:" , name , data ) ;\n} ) ;\n```\n\n\n\n<a name="ref.getCursorLocation"></a>\n### .getCursorLocation( callback )\n\n* callback( error , x , y )\n\t* error `mixed` truthy if an underlying error occurs\n\t* x `integer` the x coordinate of the cursor\n\t* y `integer` the y coordinate of the cursor\n\nGet the cursor location.\n\n\n\n<a name="ref.getColor"></a>\n### .getColor( register , callback )\n\n* register `number` the register number in the 0..255 range\n* callback( error , rgb )\n\t* error `mixed` truthy if an underlying error occurs\n\t* rgb `Object` where:\n\t\t* r `number` in the 0..255 range, the red value\n\t\t* g `number` in the 0..255 range, the green value\n\t\t* b `number` in the 0..255 range, the blue value\n\nGet the RGB values of a color register.\n\n\n\n<a name="ref.setColor"></a>\n### .setColor( register , r , g , b , [names] ) *or* .setColor( register , rgb , [names] )\n\n* register `number` the register number in the 0..255 range\n* r `number` in the 0..255 range, the red value\n* g `number` in the 0..255 range, the green value\n* b `number` in the 0..255 range, the blue value\n* rgb `Object` where:\n\t* r `number` in the 0..255 range, the red value\n\t* g `number` in the 0..255 range, the green value\n\t* b `number` in the 0..255 range, the blue value\n* names `Array` of `string`: names for that color, it default to an empty array\n\nSet the RGB values for a color indexed by the integer *register*.\n\n\n\n<a name="ref.getPalette"></a>\n### .getPalette( register , callback )\n\n* callback( error , palette )\n\t* error `mixed` truthy if an underlying error occurs\n\t* palette `Array` of 16 `Object` where:\n\t\t* r `number` in the 0..255 range, the red value\n\t\t* g `number` in the 0..255 range, the green value\n\t\t* b `number` in the 0..255 range, the blue value\n\t\t* names `Array` of `string`, names for this color\n\nRequest from the terminal the 16-colors palette in use.\n\nIf the terminal does not support the feature, then the default palette for this terminal is provided,\nand each color that was modified by the lib replace it.\n\n\n\n<a name="ref.setPalette"></a>\n### .setPalette( palette )\n\n* palette either:\n\t* `Array` of 16 `Object` where:\n\t\t* r `number` in the 0..255 range, the red value\n\t\t* g `number` in the 0..255 range, the green value\n\t\t* b `number` in the 0..255 range, the blue value\n\t\t* names `Array` of `string`, names for this color\n\t* *OR* `string` one of the built-in palette (default, gnome, konsole, linux, solarized, vga, xterm)\n\nIf the terminal support it, it will reset the 16-colors palette to the provided one.\n\n\n\n<a name="ref.yesOrNo"></a>\n### .yesOrNo( [options] , callback )\n\n* options `Object` where:\n\t* yes `string` or `Array` contains a key code or an array of key code that will trigger the yes\n\t* no `string` or `Array` contains a key code or an array of key code that will trigger the \n\t* echoYes `String` contains what to write on yes, default \'yes\'\n\t* echoNo `String` contains what to write on no, default \'no\'\n* callback( error , result )\n\t* error `mixed` truthy if an underlying error occurs\n\t* result `boolean` true for \'yes\' or false for \'no\'\n\nWait for user input, call the completion callback when the user hit the \'y\' key or the \'n\' key,\n*result* will be true if the user hit any *yes* keys or false if the user hit any *no* keys.\nOther keys do not do anything.\n\nTurn input grabbing on if necessary.\n\nWe can specify the keys for *yes* and *no* by providing a string or an array of string.\n\nIt returns an object featuring some functions to control things during the input process:\n\n* abort(): abort the input process and do not even call the inputField()\'s callback\n\n\n\nQuick example:\n\n```js\nvar term = require( \'terminal-kit\' ).terminal ;\n\nfunction question()\n{\n\tterm( \'Do you like javascript? [Y|n]\\n\' ) ;\n\t\n\t// Exit on y and ENTER key\n\t// Ask again on n\n\tterm.yesOrNo( { yes: [ \'y\' , \'ENTER\' ] , no: [ \'n\' ] } , function( error , result ) {\n\t\n\t\tif ( result )\n\t\t{\n\t\t\tterm.green( "\'Yes\' detected! Good bye!\\n" ) ;\n\t\t\tprocess.exit() ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tterm.red( "\'No\' detected, are you sure?\\n" ) ;\n\t\t\tquestion() ;\n\t\t}\n\t} ) ;\n}\n\nquestion() ;\n```\n\nIt produces:\n\n![Yes or no output](https://raw.githubusercontent.com/cronvel/terminal-kit/master/sample/yes-no-doc1.gif)\n\n\n\n<a name="ref.inputField"></a>\n### .inputField( [options] , callback )\n\n* options `Object` where:\n\t* echo `boolean` if true (the default), input are displayed on the terminal\n\t* history `Array` (optional) an history array, so UP and DOWN keys move up and down in the history\n\t* maxLength `number` (optional) the maximum length (in characters) of the user input\n\t* autoComplete `Array` or `Function( inputString , [callback] )` (optional) an array of possible completion,\n\t  so the TAB key will auto-complete the input field. If it is a function, it should accept an input `string`\n\t  and return the completed `string` (if no completion can be done, it should return the input string,\n\t  if multiple candidate are possible, it should return an array of string), if **the function accepts 2 arguments**\n\t  (checked using *function*.length), then **the auto-completer will be asynchronous**!\n\t  Also note that if it is an array or the result of the function is an array, and if that array has a\n\t  special property `prefix` (a string), then this prefix will be prepended to the output of the auto complete menu.\n\t* autoCompleteMenu `boolean` or `Object` of options, used in conjunction with the \'autoComplete\' options, if *truthy*\n\t  any auto-complete attempt having many completion candidates will display a menu to let the user choose between each\n\t  possibilities. If an object is given, it should contain options for the [.singleLineMenu()](#ref.singleLineMenu)\n\t  that is used for the completion (notice: some options are overwritten: \'y\' and \'exitOnUnexpectedKey\')\n* callback( error , input )\n\t* error `mixed` truthy if an underlying error occurs\n\t* input `string` the user input\n\nWait for user input, call the completion callback when the user hit the *ENTER* key and pass the user input\nto the callback.\n\nIt turns input grabbing on if necessary.\n\nSpecial keys supported by the input field:\n\n* ENTER, KP_ENTER: end the input process and return the current user input\n* DELETE: delete\n* BACKSPACE: backward delete\n* LEFT, RIGHT: move the cursor one character left or right\n* HOME: move the cursor at the beginning of the input field\n* END: move the cursor at the end of the input field\n* DOWN, UP: use the history feature (if `options.history` is set)\n* TAB: use the auto-completion feature (if `options.autoComplete` is set)\n\nAdditional keys are used when the auto-completion displays its menu (see [.singleLineMenu()](#ref.singleLineMenu) for details).\n\nIt returns an EventEmitter object featuring some functions to control things during the input process:\n\n* abort(): abort the input process and do not even call the inputField()\'s callback\n* stop(): stop the input process now, call the inputField()\'s callback (same behavior than a regular \'ENTER\' key pressed)\n* getInput(): get the current input string\n* getPosition(): return an object containing \'x\' and \'y\' properties, the coordinates where the input field starts\n* redraw(): redraw the input field, useful if you had echo\'ed something that can mess it\n* hide(): hide the input field, it still records keystrokes\n* show(): show the input field again\n* rebase(): rebase the input field to the current cursor position. Please note: it does NOT erase the previously entered\n  text, you have to use hide() before. It works this way because you may want to modify the screen in between, and\n  it needs some I/O with the terminal to works accordingly.\n\nIt emits:\n\n* *ready*: when the input field is ready (rarely useful)\n\n\n\nQuick example, featuring *history* and *auto-completion*:\n\n```js\nvar term = require( \'terminal-kit\' ).terminal ;\n\nvar history = [ \'John\' , \'Jack\' , \'Joey\' , \'Billy\' , \'Bob\' ] ;\n\nvar autoComplete = [\n\t\'Barack Obama\' , \'George W. Bush\' , \'Bill Clinton\' , \'George Bush\' ,\n\t\'Ronald W. Reagan\' , \'Jimmy Carter\' , \'Gerald Ford\' , \'Richard Nixon\' ,\n\t\'Lyndon Johnson\' , \'John F. Kennedy\' , \'Dwight Eisenhower\' ,\n\t\'Harry Truman\' , \'Franklin Roosevelt\'\n] ;\n\nterm( \'Please enter your name: \' ) ;\n\nterm.inputField(\n\t{ history: history , autoComplete: autoComplete , autoCompleteMenu: true } ,\n\tfunction( error , input ) {\n\n\t\tterm.green( "\\nYour name is \'%s\'\\n" , input ) ;\n\t\tprocess.exit() ;\n\t}\n) ;\n```\n\nIt produces:\n\n![Input field output](https://raw.githubusercontent.com/cronvel/terminal-kit/master/sample/input-field-doc1.gif)\n\nIf we need our own auto-completer, we might take advantage of the built-in static method [termkit.autoComplete()](#ref.autoComplete).\n\nCustom auto-completer can be asynchronous, if the function\'s *length* is **exactly 2**.\n\n<a name="ref.example.autoComplete"></a>\nThis is an example of a file selector that exposes the async behavior of auto-completer and the usage of\nthe static `termkit.autoComplete()` method:\n\n```js\nvar fs = require( \'fs\' ) ;\nvar termkit = require( \'terminal-kit\' ) ;\nvar term = termkit.terminal ;\n\nvar autoCompleter = function autoCompleter( inputString , callback )\n{  \n    fs.readdir( __dirname , function( error , files ) {\n        callback( undefined , termkit.autoComplete( files , inputString , true ) ) ;\n    } ) ;\n} ;\n    \nterm( \'Choose a file: \' ) ;\n\nterm.inputField(\n\t{ autoComplete: autoCompleter , autoCompleteMenu: true } ,\n\tfunction( error , input ) {\n\t\tif ( error )\n\t\t{\n\t\t\tterm.red.bold( "\\nAn error occurs: " + error + "\\n" ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tterm.green( "\\nYour file is \'%s\'\\n" , input ) ;\n\t\t}\n\t\t\n\t\tprocess.exit() ;\n\t}\n) ;\n```\n\nIt produces:\n\n![Input field output](https://raw.githubusercontent.com/cronvel/terminal-kit/master/sample/input-field-doc2.gif)\n\nAlso note that if the `autoComplete` options is an array or if it is a function whose output is an array, \na special property `prefix` (a string) can be set on it: this prefix will be prepended to the output of the auto complete menu.\n\n\n\n<a name="ref.singleLineMenu"></a>\n### .singleLineMenu( menuItems , [options] , callback )\n\n* menuItems `array` of menu item text\n* options `object` of options, where:\n\t* y `number` the line where the menu will be displayed, default to the next line\n\t* separator `string` (default: \'  \') the string separating each menu item\n\t* nextPageHint `string` (default: \' » \') string indicator for a next page\n\t* previousPageHint `string` (default: \' « \') string indicator for a previous page\n\t* style `function` the style of unselected items, default to the current `term`\n\t* selectedStyle `function` the style of the selected item, default to `term.dim.blue.bgGreen`\n\t* exitOnUnexpectedKey `boolean` if an unexpected key is pressed, it exits, calling the callback with undefined values\n* callback( error , response ), where:\n\t* error `mixed` truthy if an underlying error occurs\n\t* response `Object` where\n\t\t* selectedIndex `number` the user-selected menu item index\n\t\t* selectedText `string` the user-selected menu item text\n\t\t* x `number` the x coordinate of the selected menu item (the first character)\n\t\t* y `number` the y coordinate of the selected menu item (same coordinate for all items since it\'s a single line menu)\n\t\t* unexpectedKey `string` when \'exitOnUnexpectedKey\' option is set and an unexpected key is pressed, this contains\n\t\t  the key that produced the exit\n\nIt creates an interactive menu that uses only a single line.\n\nIt features **paging** if items oversize the line length, and supports the following keys:\n\n* ENTER, KP_ENTER: end the process and return the currently selected menu item\n* LEFT, RIGHT: move and select the previous or the next item in the menu\n* UP, DOWN: go the previous or the next page of items (if paging is used)\n* HOME, END: move and select the first or the last item of the menu\n\nIf the \'exitOnUnexpectedKey\' option is set, any other keys will exit the menu, the callback\'s *response* argument\ndoes not contain any property except \'unexpectedKey\', that will contain the key having triggered the exit.\n\nExample:\n\n```js\nvar term = require( \'terminal-kit\' ).terminal ;\n\nvar items = [ \'File\' , \'Edit\' , \'View\' , \'History\' , \'Bookmarks\' , \'Tools\' , \'Help\' ] ;\n\nvar options = {\n\ty: 1 ,\t// the menu will be on the top of the terminal\n\tstyle: term.inverse ,\n\tselectedStyle: term.dim.blue.bgGreen\n} ;\n\nterm.clear() ;\n\nterm.singleLineMenu( items , options , function( error , response ) {\n\tterm( \'\\n\' ).eraseLineAfter.green(\n\t\t"#%s selected: %s (%s,%s)\\n" ,\n\t\tresponse.selectedIndex ,\n\t\tresponse.selectedText ,\n\t\tresponse.x ,\n\t\tresponse.y\n\t) ;\n\tprocess.exit() ;\n} ) ;\n```\n\nIt produces:\n\n![Progress bar output](https://raw.githubusercontent.com/cronvel/terminal-kit/master/sample/single-line-menu-doc1.gif)\n\nIt creates a menu on the top of the terminal, with unselected items using inverted foreground/background colors,\nand the selected item using blue on green.\nWhen the user press RETURN/ENTER, it displays the index, text and coordinates of the selected menu item.\n\n\n\n<a name="ref.progressBar"></a>\n### .progressBar( [options] )\n\n* options `object` of options, all of them are **OPTIONAL**, where:\n\t* width: `number` the total width of the progress bar, default to the max available width\n\t* percent: `boolean` if true, it shows the progress in percent alongside with the progress bar\n\t* eta: `boolean` if true, it shows the Estimated Time of Arrival alongside with the progress bar\n\t* items `number` the number of items that should be completed, turns the *item mode* on\n\t* title `string` the title of the current progress bar, turns the *title mode* on\n\t* barStyle `function` the style of the progress bar items, default to `term.cyan`\n\t* barBracketStyle `function` the style of the progress bar bracket character, default to options.barStyle if given\n\t  or `term.blue`\n\t* percentStyle `function` the style of percent value string, default to `term.yellow`\n\t* etaStyle `function` the style of the ETA display, default to `term.bold`\n\t* itemStyle `function` the style of the item display, default to `term.dim`\n\t* titleStyle `function` the style of the title display, default to `term.bold`\n\t* itemSize `number` the size of the item status, default to 33% of width\n\t* titleSize `number` the size of the title, default to 33% of width or title.length depending on context\n\t* barChar `string` the char used for the bar, default to \'=\'\n\t* barHeadChar `string` the char used for the bar, default to \'>\'\n\t* maxRefreshTime `number` the maximum time between two refresh in ms, default to 500ms\n\t* minRefreshTime `number` the minimum time between two refresh in ms, default to 100ms\n\nIt creates a nice progress bar and return a controller object to interact with it.\n\nThe controller provides those functions:\n\n* update( updateObject ): update the progress bar, having the arguments:\n\t* updateObject `object` or `number` or `null`. If *updateObject* is not an object, it\'s a shorthand for `{ progress: value }`.\n\t  It supports those properties:\n\t\t* progress `number` or `null` the progress value:\n\t\t\t* if it\'s a float between 0 and 1, it\'s the actual progress value to be displayed\n\t\t\t* if `null` then it will display a spinning wheel: something is in progress, but cannot be quantified\n\t\t* items `number` change the number of items that should be completed, turns the *item mode* on\n\t\t* title `string` change the title of the current progress bar, turns the *title mode* on\n\n* startItem( name ): in *item mode*, it informs the progress bar that a new item is processing, having arguments:\n\t* name `string` the name of the item that will be displayed in the item status part of the progress bar\n\n* itemDone( name ): in *item mode*, it informs the progress bar that an item is now done, if that item was started using\n  `.startItem()`, it will be removed from the running item list. When the number of finished item reaches the `items` parameter\n  (see the `.progressBar()`\'s \'items\' option or `.update()` method\'s \'items\' option), the progressBar reaches 100% and stop.\n  It has the arguments:\n\t* name `string` the name of the item that just finished.\n\n* stop(): stop the progress bar, no redraw will occurs\n\n* resume(): resume a previously stopped progress bar, it will be redrawn again\n\n\n\nExample of a progress bar using fake progress values:\n\n```js\nvar term = require( \'terminal-kit\' ).terminal ;\n\nvar progressBar , progress = 0 ;\n\n\nfunction doProgress()\n{\n\t// Add random progress\n\tprogress += Math.random() / 10 ;\n\tprogressBar.update( progress ) ;\n\t\n\tif ( progress >= 1 )\n\t{\n\t\t// Cleanup and exit\n\t\tsetTimeout( function() { term( \'\\n\' ) ; process.exit() ; } , 200 ) ;\n\t}\n\telse\n\t{\n\t\tsetTimeout( doProgress , 100 + Math.random() * 400 ) ;\n\t}\n}\n\n\nprogressBar = term.progressBar( {\n\twidth: 80 ,\n\ttitle: \'Serious stuff in progress:\' ,\n\teta: true ,\n\tpercent: true\n} ) ;\n\ndoProgress() ;\n```\n\nIt produces:\n\n![Progress bar output](https://raw.githubusercontent.com/cronvel/terminal-kit/master/sample/progress-bar-doc1.gif)\n\nIt creates a progress bar and feeds it with a random progress value, then quit when it reaches 100%.\n\n\nExample of a progress bar in *item mode*:\n\n```js\nvar term = require( \'terminal-kit\' ).terminal ;\n\nvar progressBar ;\n\nvar thingsToDo = [\n\t\'update my lib\' ,\n\t\'data analyzing\' ,\n\t\'serious business\' ,\n\t\'decrunching data\' ,\n\t\'do my laundry\' ,\n\t\'optimizing\'\n] ;\n\nvar countDown = thingsToDo.length ;\n\n\nfunction start()\n{\n\tif ( ! thingsToDo.length ) { return ; }\n\t\n\tvar task = thingsToDo.shift() ;\n\t\n\tprogressBar.startItem( task ) ;\n\t\n\t// Finish the task in...\n\tsetTimeout( done.bind( null , task ) , 500 + Math.random() * 1200 ) ;\n\t\n\t// Start another parallel task in...\n\tsetTimeout( start , 400 + Math.random() * 400 ) ;\n}\n\n\nfunction done( task )\n{\n\tprogressBar.itemDone( task ) ;\n\tcountDown -- ;\n\t\n\t// Cleanup and exit\n\tif ( ! countDown )\n\t{\n\t\tsetTimeout( function() { term( \'\\n\' ) ; process.exit() ; } , 200 ) ;\n\t}\n}\n\n\nprogressBar = term.progressBar( {\n\twidth: 80 ,\n\ttitle: \'Daily tasks:\' ,\n\teta: true ,\n\tpercent: true ,\n\titems: thingsToDo.length\n} ) ;\n\nstart() ;\n```\n\nIt produces:\n\n![Progress bar output](https://raw.githubusercontent.com/cronvel/terminal-kit/master/sample/progress-bar-doc2.gif)\n\nIt creates a progress bar and start and finish task with a random time, then quit when everything is done.\n\n\n\n<a name="ref.slowTyping"></a>\n### .slowTyping( str , [options] , callback )\n\n* str `string` the text to display\n* options `object` of options, where:\n\t* style `function` the style of text, default to `term.green`\n\t* flashStyle `function` or `falsy` if a `function` is given, then this is the style of the text for the flash effect,\n\t\tif `falsy` then the flash effect is turn off, default to `term.bold.brightGreen`\n\t* delay `number` average delay before printing the next char, default to 150 ms\n\t* flashDelay `number` fixed delay before the `flashStyle` of the last printed char is replaced by the regular `style`,\n\t\tdefault to 100 ms\n* callback `function` that will be called on completion\n\nIt outputs some text with an old-fashioned slow-typing effect.\n\nExample:\n\n```js\nvar term = require( \'terminal-kit\' ).terminal ;\n\nterm.slowTyping(\n\t\'What a wonderful world!\\n\' ,\n\t{ flashStyle: term.brightWhite } ,\n\tfunction() { process.exit() ; }\n) ;\n```\n\nIt produces:\n\n![Slow typing output](https://raw.githubusercontent.com/cronvel/terminal-kit/master/sample/slow-typing-doc1.gif)\n\n\n\n## Events\n\nEvent are fired on your `term` object.\n\n\n\n<a name="ref.event.resize"></a>\n### \'resize\' event ( width , height )\n\n* width `number` the new width in character\n* height `number` the new height in character\n\nThe \'resize\' event is emitted when the terminal get resized, and it contains the new width and height.\nAlso `term.width` and `term.height` are updated too.\n\n\n\n<a name="ref.event.key"></a>\n### \'key\' event ( name , matches , data )\n\n* name `string` the key name\n* matches `Array` of matched key name\n* data `Object` contains more informations, mostly useful for debugging purpose, where:\n\t* isCharacter `boolean` is true if this is a *regular* character, i.e. *not* a control character\n\t* codepoint `number` (optional) the utf-8 code point of the character, if relevant\n\t* code `number` or `Buffer`, for multibyte character it is the raw `Buffer` input, for single byte character it is a `number`\n\t  between 0 and 255\n\nThe \'key\' event is emitted whenever the user type something on the keyboard.\n\nIf `name` is a single char, this is a regular UTF8 character, entered by the user.\nIf the user type a word, each UTF8 character will produce its own \'key\' event.\n\nIf `name` is a multiple chars string, then it is a SPECIAL key.\n\n<a name="ref.event.key.specialKeyCodes"></a>\nList of SPECIAL keys:\n\n    ESCAPE ENTER BACKSPACE NUL TAB SHIFT_TAB \n    UP DOWN RIGHT LEFT\n    INSERT DELETE HOME END PAGE_UP PAGE_DOWN\n    KP_NUMLOCK KP_DIVIDE KP_MULTIPLY KP_MINUS KP_PLUS KP_DELETE KP_ENTER\n    KP_0 KP_1 KP_2 KP_3 KP_4 KP_5 KP_6 KP_7 KP_8 KP_9\n    F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12\n    SHIFT_F1 SHIFT_F2 SHIFT_F3 SHIFT_F4 SHIFT_F5 SHIFT_F6\n\tSHIFT_F7 SHIFT_F8 SHIFT_F9 SHIFT_F10 SHIFT_F11 SHIFT_F12\n    CTRL_F1 CTRL_F2 CTRL_F3 CTRL_F4 CTRL_F5 CTRL_F6\n\tCTRL_F7 CTRL_F8 CTRL_F9 CTRL_F10 CTRL_F11 CTRL_F12\n    CTRL_SHIFT_F1 CTRL_SHIFT_F2 CTRL_SHIFT_F3 CTRL_SHIFT_F4\n\tCTRL_SHIFT_F5 CTRL_SHIFT_F6 CTRL_SHIFT_F7 CTRL_SHIFT_F8\n\tCTRL_SHIFT_F9 CTRL_SHIFT_F10 CTRL_SHIFT_F11 CTRL_SHIFT_F12\n    SHIFT_UP SHIFT_DOWN SHIFT_RIGHT SHIFT_LEFT\n    ALT_UP ALT_DOWN ALT_RIGHT ALT_LEFT\n    CTRL_UP CTRL_DOWN CTRL_RIGHT CTRL_LEFT\n    SHIFT_INSERT SHIFT_DELETE SHIFT_HOME SHIFT_END SHIFT_PAGE_UP SHIFT_PAGE_DOWN\n    CTRL_INSERT CTRL_DELETE CTRL_HOME CTRL_END CTRL_PAGE_UP CTRL_PAGE_DOWN\n    ALT_INSERT ALT_DELETE ALT_HOME ALT_END ALT_PAGE_UP ALT_PAGE_DOWN\n\tSHIFT_TAB ALT_TAB\n\tALT_SPACE CTRL_ALT_SPACE\n\nAnd modifier on regular A-Z key:\n\n    CTRL_A ALT_A CTRL_ALT_A ALT_SHIFT_A\n    CTRL_B ALT_B CTRL_ALT_B ALT_SHIFT_B\n    CTRL_C ALT_C CTRL_ALT_C ALT_SHIFT_C\n    ...\n\nSometime, a key matches multiple combination. For example CTRL-M on linux boxes is always the same as ENTER.\nSo the event will provide as the \'name\' argument the most useful/common, here *ENTER*.\nHowever the \'matches\' argument will contain `[ ENTER , CTRL_M ]`.\n\nAlso notice that some terminal will support less keys. For example, the Linux Console does not support SHIFT/CTRL/ALT + Arrows keys,\nit will produce a normal arrow key.\nThere is no workaround here, the underlying keyboard driver simply does not support this.\n\nKP_* keys needs `applicationKeypad()`, e.g. without it KP_1 will report \'1\' or END.\n\nSome terminal does not support `applicationKeypad()` at all, sometime turning numlock off can works, sometime not,\nso it is nearly impossible to differentiate (for example) a KP_1 from an END, or a KP_7 from a HOME.\n\n\n\n<a name="ref.event.terminal"></a>\n### \'terminal\' event ( name , data )\n\n* name `string` the name of the subtype of event\n* data `Object` provide some data depending on the event\'s subtype\n\nThe \'terminal\' event is emitted for terminal generic information.\n\nThe argument \'name\' can be:\n\n* CURSOR_LOCATION: it is emitted in response of a requestCursorLocation(), data contains \'x\' & \'y\', the coordinate of the cursor.\n\n* SCREEN_RESIZE: **DEPRECATED! Will be removed in the next non-patch version! Use the \'resize\' event instead!**\n  Currently it is emitted when a terminal resizing is detected, most of time node.js will be notified of\n  screen resizing, and so this event will be emitted, data contains \'width\' & \'height\', the size of the screen in characters\n\n* SCREEN_SIZE: **rarely useful** it is emitted in response of a requestScreenSize(), data contains \'width\' & \'height\', the size of\n  the screen in characters, and \'resized\' (true/false) if the size has changed without node.js being notified\n\n* FOCUS_IN: it is emitted if the terminal gains focus (if supported by your terminal)\n\n* FOCUS_OUT: it is emitted if the terminal loses focus (if supported by your terminal)\n\n\n\n<a name="ref.event.mouse"></a>\n### \'mouse\' event ( name , data )\n\n* name `string` the name of the subtype of event\n* data `Object` provide the mouse coordinates and keyboard modifiers status, where:\n\t* x `number` the row number where the mouse is\n\t* y `number` the column number where the mouse is\n\t* ctrl `boolean` true if the CTRL key is down or not\n\t* alt `boolean` true if the ALT key is down or not\n\t* shift `boolean` true if the SHIFT key is down or not\n\nActivated when grabInput() is used with the \'mouse\' options, e.g. `{ mouse: \'button\' }`, `{ mouse: \'drag\' }` or `{ mouse: \'motion\' }`.\n\nThe argument \'name\' can be:\n\n* MOUSE_LEFT_BUTTON_PRESSED: well... it is emitted when the left mouse button is pressed\n* MOUSE_LEFT_BUTTON_RELEASED: when this button is released\n* MOUSE_RIGHT_BUTTON_PRESSED, MOUSE_RIGHT_BUTTON_RELEASED, MOUSE_MIDDLE_BUTTON_PRESSED, MOUSE_MIDDEL_BUTTON_RELEASED: self explanatory\n* MOUSE_WHEEL_UP, MOUSE_WHEEL_DOWN: self explanatory\n* MOUSE_OTHER_BUTTON_PRESSED, MOUSE_OTHER_BUTTON_RELEASED: a fourth mouse button is sometime supported\n* MOUSE_BUTTON_RELEASED: a button were released, however the terminal does not tell us which one\n* MOUSE_MOTION: if the options `{ mouse: \'motion\' }` is passed to grabInput(), every moves of the mouse will fire this event,\n  if `{ mouse: \'drag\' }` is given, it will be fired if the mouse move while a button is pressed\n\n\n\n\n\n## Static methods of `termkit`, the module\'s root\n\n\n\n<a name="ref.createTerminal"></a>\n### .createTerminal( options )\n\n* options `Object` an object of options, where:\n\t* stdin `stream.Readable` (default: `process.stdin`) a readable input stream for the terminal interface\'s input\n\t* stdout `stream.Writable` (default: `process.stdout`) a writable output stream for the terminal interface\'s output\n\t* stderr `stream.Writable` (default: `process.stderr`) a writable output stream for the terminal interface\'s error output\n\t* generic `string` (default: \'xterm\') generic terminal application\'s identifier\n\t* appId `string` specific terminal application\'s identifier (available ID\'s are files basename found in the\n\t  lib/termconfig/ directory of the lib)\n\t* appName `string` just an informative field\n\t* processSigwinch `boolean` (default: false) true if the terminal can use the SIGWINCH signal to detect resizing\n\nThis method creates a new terminal interface.\n\nMost of time, one may just use the default terminal interface, using `var term = require( \'terminal-kit\' ).terminal ;`.\nThat should cover 98% of use cases.\n\nHowever, it is sometime useful if we have some communication channel to a terminal other than STDIN/STDOUT,\nor if we know for sure the targeted terminal\'s ID and don\'t want to use the autodetect feature of the lib.\n\n\n\n<a name="ref.getParentTerminalInfo"></a>\n### .getParentTerminalInfo( callback )\n\n* callback `Function( error , codename , name , pid )` where:\n\t* error: truthy if it has failed for some reason\n\t* codename: the code name of the terminal, as used by terminfo\n\t* name: the real binary name of the terminal\n\t* pid: the PID of the terminal\n\nThis method detects on which terminal your application run.\nIt does **\\*NOT\\*** use the $TERM or $COLORTERM environment variable, except as a fallback.\nIt iterates through parent process until a known terminal is found, or process of PID 1 is reached (the *init* process).\n\nObviously, it does not works over SSH.\n\nAlso, it only works on UNIX family OS.\n\n\n\n<a name="ref.getDetectedTerminal"></a>\n### .getDetectedTerminal( callback )\n\n* callback `Function( error , term )` where:\n\t* error: truthy if it has failed for some reason\n\t* term: the terminal object created specifically for your terminal\n\nThis is a shortcut that call `.getParentTerminalInfo()` then use `.createTerminal()` with the correct arguments.\nThis will give you a terminal object with the best support that this lib is able to give to you.\n\nIt does not works over SSH, but fallback to standard terminal guessing.\n\nExample **\\*NOT\\***  using `.getDetectedTerminal()`:\n```js\nvar term = require( \'terminal-kit\' ).terminal ;\nterm.cyan( \'Hello world!\' ) ;\n```\nThis will give you a terminal object based on the $TERM and $COLORTERM environment variable, that works fine in\nalmost all cases.\n\nSome troubles may arise if the $COLORTERM environment variable is not found.\n\nMost of modern terminal report them as an *xterm* or an *xterm-256color* terminal in the $TERM environment variable.\nThey claim being xterm-compatible, but most of them support only 33% to 50% of xterm features,\nand even major terminal like *gnome-terminal* or *Konsole* are sometimes terrible.\n\nExample using `.getDetectedTerminal()`:\n```js\nrequire( \'terminal-kit\' ).getDetectedTerminal( function( error , term ) {\n\tterm.cyan( \'Terminal name: %s\\n\' , term.appName ) ;\n\tterm.cyan( \'Terminal app: %s\\n\' , term.app ) ;\n\tterm.cyan( \'Terminal generic: %s\\n\' , term.generic ) ;\n\tterm.cyan( \'Config file: %s\\n\' , term.termconfigFile ) ;\n} ) ;\n```\nThis will give you the best compatibility possible, at the cost of a callback.\n\n\n\n<a name="ref.autoComplete"></a>\n### .autoComplete( array , startString , [returnAlternatives] , [prefix] )\n\n* array `Array` of string, it is the list of completion candidates\n* startString `string` this is the input string to be completed\n* returnAlternatives `boolean` (default: false) when many candidates match the input, if *returnAlternatives* is set then\n  the method is allowed to return an array containing all matching candidates, else the input string (*startString*) is\n  returned unchanged\n* prefix `string` (optional) prepend that string to the response string, or add a `prefix` property to the response array:\n  when used in an `inputField()`, this cause this string to be prepended to the output of the auto-complete menu.\n\nThis static method is used behind the scene by [.inputField()](#ref.inputField) when auto-completion mechanisms kick in.\n\nThis method is exposed in the API because [.inputField()](#ref.inputField) supports user-defined auto-completers, such\nauto-completers might take advantage of this method for its final pass, after collecting relevant informations to feed it.\n\n[This is an example](#ref.example.autoComplete) of its usage.\n\n\n',
21 silly publish   readmeFilename: 'README.md',
21 silly publish   gitHead: '7e98ab2d4b6b88919afd1f0e83c5ca8a75e61525',
21 silly publish   homepage: 'https://github.com/cronvel/terminal-kit#readme',
21 silly publish   _id: 'terminal-kit@0.25.0',
21 silly publish   _shasum: '393a9cd3d694ef738ea5efaa27095b424e30082d',
21 silly publish   _from: '.' }
22 verbose getPublishConfig undefined
23 silly mapToRegistry name terminal-kit
24 silly mapToRegistry using default registry
25 silly mapToRegistry registry https://registry.npmjs.org/
26 silly mapToRegistry data Result {
26 silly mapToRegistry   raw: 'terminal-kit',
26 silly mapToRegistry   scope: null,
26 silly mapToRegistry   escapedName: 'terminal-kit',
26 silly mapToRegistry   name: 'terminal-kit',
26 silly mapToRegistry   rawSpec: '',
26 silly mapToRegistry   spec: 'latest',
26 silly mapToRegistry   type: 'tag' }
27 silly mapToRegistry uri https://registry.npmjs.org/terminal-kit
28 verbose publish registryBase https://registry.npmjs.org/
29 silly publish uploading /home/cedric/.npm/terminal-kit/0.25.0/package.tgz
30 verbose request uri https://registry.npmjs.org/terminal-kit
31 verbose request sending authorization for write operation
32 info attempt registry request try #1 at 3:09:12 PM
33 verbose request id d5d2d43c15490214
34 http request PUT https://registry.npmjs.org/terminal-kit
35 info retry will retry, error on last attempt: Error: socket hang up
36 info attempt registry request try #2 at 3:19:35 PM
37 http request PUT https://registry.npmjs.org/terminal-kit
38 http 200 https://registry.npmjs.org/terminal-kit
39 verbose headers { 'content-type': 'application/json',
39 verbose headers   'content-encoding': 'gzip',
39 verbose headers   'cache-control': 'max-age=300',
39 verbose headers   'transfer-encoding': 'chunked',
39 verbose headers   'accept-ranges': 'bytes',
39 verbose headers   date: 'Tue, 01 Nov 2016 14:20:27 GMT',
39 verbose headers   via: '1.1 varnish',
39 verbose headers   connection: 'keep-alive',
39 verbose headers   'x-served-by': 'cache-lcy1150-LCY',
39 verbose headers   'x-cache': 'MISS',
39 verbose headers   'x-cache-hits': '0',
39 verbose headers   'x-timer': 'S1478009975.830165,VS0,VE51696',
39 verbose headers   vary: 'Accept-Encoding' }
40 verbose request invalidating /home/cedric/.npm/registry.npmjs.org/terminal-kit on PUT
41 info lifecycle terminal-kit@0.25.0~publish: terminal-kit@0.25.0
42 verbose stack Error: write EPIPE
42 verbose stack     at exports._errnoException (util.js:1026:11)
42 verbose stack     at WriteWrap.afterWrite (net.js:799:14)
43 verbose cwd /home/cedric/inside/github/terminal-kit
44 error Linux 4.7.7-100.fc23.x86_64
45 error argv "/opt/node.js-v6.9.1/bin/node" "/usr/bin/npm" "publish"
46 error node v6.9.1
47 error npm  v3.10.8
48 error code EPIPE
49 error errno EPIPE
50 error syscall write
51 error write EPIPE
52 error If you need help, you may report this error at:
52 error     <https://github.com/npm/npm/issues>
53 verbose exit [ 1, true ]
